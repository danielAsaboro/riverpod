---
title: Why Riverpod?
version: 1
---

import whyRiverpod from "./why_riverpod";
import { AutoSnippet } from "../../src/components/CodeSnippet";

## What is Riverpod?

Riverpod (anagram of [Provider](https://pub.dev/packages/provider)) is a reactive
caching framework for Flutter/Dart.

Using declarative and reactive programming, Riverpod takes care of a large part of your application's logic by significantly reducing the need for repetitive, boilerplate code. 

One of its standout features is its ability to seamlessly manage network requests, complete with built-in error handling and efficient caching mechanisms. More than that,
you don't have to manually intervene in ensuring your application stays up-to-date and responsive to changes in data sources.— it does that for you by intelligently re-fetching data as needed

## Motivation

Modern applications rarely come with all the information necessary to render
their User Interface. Else, the app size would be bulky and content would stay outdated
really quickly. Instead of that, data is often fetched asynchronously from a server.

But that comes along with a problem: Working with asynchronous code.

For some reason, it's hard.

While Flutter offers ways to create state variables and update the user interface in
response to changes, it has certain limitations. In fact, several challenges in this regard 
still await solutions (no pun intended):

For example,

- It's impractical to repeatedly re-execute asynchronous requests whenever the UI updates. So 
  they need to be cached.
- With the introduction of Caches, it can get out of date real quick with extra care, and
- Alongside managing cached data, we must also effectively address error handling and loading states.


Solving these issues on a large scale can prove challenging as they are influenced by quite 
a number of features regularly used in modern-day apps. They include but are not limited to:

- Pull to refresh,
- Infinite lists (fetch as we scroll),
- Search as I type,
- Debouncing asynchronous requests to reduce server calls,
- Cancelling asynchronous requests when no longer used,
- Optimistic UIs,
- Offline mode and so on...


These features can be tricky to implement but they are crucial for a good user experience.

Yet, only a few packages try to tackle those problems directly, and you still have to 
do a lot of manual work to get anything barely going — and that's where Riverpod comes in.

Inspired by Flutter widgets, Riverpod addresses these challenges by introducing a fresh and
unique approach to constructing business logic. So Riverpod is comparable to widgets in many
ways but it's specifically for state. 

Using this new approach, these complex features are mostly done by default. All
that's left is to focus on your UI.

Skeptical? Here's an example. The following snippet is a simplification of the [Pub.dev](https://github.com/rrousselGit/riverpod/tree/master/examples/pub)
client application implemented using Riverpod.

<AutoSnippet language="dart" {...whyRiverpod}></AutoSnippet>

This snippet is all the business logic you need for a "search as we type" +
"pull to refresh" + "infinite list", while handling error/loading states.
